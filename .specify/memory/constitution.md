<!--
  Sync Impact Report
  ==================
  Version change: 1.0.0 → 1.0.1
  Bump rationale: PATCH — removed Chinese annotations from principle
    headings; all content now in English per project language policy.

  Modified principles (title changes only, no semantic changes):
    - I. Risk First, Always — subtitle changed to (Absolute Risk Veto)
    - II. Isomorphic Execution — subtitle changed to (Backtest-Live Parity)
    - III. Human-in-the-Loop — subtitle changed to (Clear Human-AI Boundary)
    - IV. Strict Boundary Decoupling — subtitle changed to (Domain-Driven Isolation)

  Added sections: None
  Removed sections: None

  Templates requiring updates:
    - .specify/templates/plan-template.md         — ⚠ pending
      (Constitution Check section must enumerate Tino-specific gates)
    - .specify/templates/spec-template.md          — ✅ compatible as-is
    - .specify/templates/tasks-template.md          — ✅ compatible as-is
    - .specify/templates/agent-file-template.md     — ✅ compatible as-is

  Deferred items:
    - None
-->

# Tino Constitution

## Core Principles

### I. Risk First, Always (Absolute Risk Veto)

The system trades real capital on cryptocurrency centralized exchanges (CEX).
Any code defect translates directly into financial loss. Risk control holds
absolute, non-bypassable veto power over every other subsystem.

- The quantitative engine MUST hard-code a global risk circuit breaker at the
  engine layer (e.g., maximum drawdown forced liquidation, single-order size
  cap, daily loss limit). This circuit breaker MUST NOT be overridable by
  AI Agent commands, CLI instructions, or API calls.
- Exchange API keys used by the engine MUST be physically isolated by
  permission scope: trading keys MUST NOT carry withdrawal permissions.
  Withdrawal-capable keys MUST never be loaded into the trading runtime.
- All risk parameter changes MUST require explicit human confirmation via
  the TUI before taking effect in the live environment.
- The engine MUST implement a kill-switch endpoint that immediately cancels
  all open orders and flattens all positions, accessible from both CLI and
  Web Dashboard.

**Rationale**: In CEX live trading, the cost of a single uncontrolled bug is
unbounded capital loss. Defense-in-depth at the engine layer is the only
acceptable mitigation.

### II. Isomorphic Execution (Backtest-Live Parity)

A strategy script generated by the AI in the CLI MUST run without any
modification in both the backtest environment and the live trading
environment. "Write once, run in both modes" is non-negotiable.

- There MUST be exactly one strategy execution interface. Backtest and live
  modes MUST differ only in the data adapter and order router injected at
  runtime, never in strategy logic.
- The codebase MUST NOT contain separate backtest-only or live-only strategy
  code paths. Any divergence is a critical defect.
- Strategy scripts MUST receive market data and submit orders through an
  abstract adapter interface (e.g., NautilusTrader's execution model) so
  that the same code path handles both historical replay and real-time
  exchange feeds.

**Rationale**: Dual-code-path systems inevitably drift. "What you test is
what you get" is the only way to trust backtest results in production.

### III. Human-in-the-Loop (Clear Human-AI Boundary)

The AI Agent (Vibecoding) is positioned as an exceptionally capable code
generator and data analyst — never as the final decision-maker. All actions
that affect the live trading environment require explicit human approval.

- Any strategy deployment, parameter adjustment, or capital allocation
  targeting the live environment MUST prompt for explicit human confirmation
  (e.g., interactive `y/N` in the TUI) before execution.
- The CLI MUST clearly distinguish between sandbox/backtest operations (safe
  to auto-execute) and live operations (MUST block for confirmation).
- AI-generated strategy code MUST be presented to the user for review before
  it is persisted or scheduled for execution. The system MUST NOT silently
  deploy AI output to live trading.

**Rationale**: AI accelerates development but cannot bear financial
responsibility. A clear approval gate prevents accidental live exposure.

### IV. Strict Boundary Decoupling (Domain-Driven Isolation)

Node.js (TypeScript) owns "speaking and seeing" — user interaction, TUI
rendering, and web dashboard presentation. Python owns "computing and
doing" — backtesting, live trading execution, and quantitative analysis.

- Node.js code MUST NOT contain any candlestick (K-line) processing,
  indicator calculation, order management logic, or exchange API calls.
- Python code MUST NOT construct frontend display strings, TUI escape
  sequences, HTML/React components, or WebSocket frame payloads intended
  for direct UI rendering.
- All cross-language communication MUST pass through a formally defined
  API contract (REST, WebSocket, or RPC), validated on both sides.
- Shared data types (e.g., OHLCV bars, order status enums, backtest result
  schema) MUST be defined in a single source-of-truth schema and code-
  generated or validated at both language boundaries.

**Rationale**: Mixing computational finance logic into the UI layer (or
vice versa) creates untestable, unreviewable hybrid code that undermines
both correctness and maintainability.

## Engineering Standards & Constraints

### Monorepo & Strategy Versioning

- The project MUST use a monorepo structure containing the Node.js CLI,
  Python Engine, and React Web Dashboard in a single Git repository with
  clear directory isolation.
- Every AI-generated strategy script (.py) MUST be content-hashed or
  git-committed upon creation. Every backtest run and live trade execution
  MUST record the exact strategy version hash, enabling full auditability
  from any trade back to its source code.

### Schema-Driven API Contracts

- All communication between Node.js and Python MUST be governed by a
  shared schema definition (e.g., JSON Schema, Protocol Buffers, or
  equivalent).
- Node.js (TypeScript) MUST validate all AI outputs and API responses
  using Zod. Python MUST validate all received parameters using Pydantic.
  Any data crossing the language boundary MUST pass type validation on
  both sides.

### AI Prompt & Interaction Standards

- **Prompt as Code**: All System Prompts MUST be maintained as versioned
  constants in dedicated files. Inline prompt string concatenation in
  business logic is prohibited.
- **Structured Output Only**: When instructing the LLM to generate backtest
  parameters, execution commands, or strategy configurations, the system
  MUST use Function Calling / Tools to enforce structured JSON output.
  Parsing natural language with regular expressions is prohibited.

## Testing & Verification Standards

### Integration-First Test Pyramid

- Integration tests have the highest priority in this system. Automated CI
  scripts MUST validate the full chain: "Node.js issues backtest command →
  Python engine loads NautilusTrader → engine returns accurate backtest
  JSON result."
- Code test coverage MUST meet a project-defined minimum threshold.
  Where feasible, Test-Driven Development (TDD) MUST be practiced:
  write tests first, verify they fail (Red), implement to pass (Green),
  then refactor.

### Data Replay Verification

- The project MUST maintain a canonical set of known cryptocurrency
  historical K-line data as a regression benchmark.
- After any update to the engine's core computation logic, the benchmark
  dataset MUST be replayed and the resulting Sharpe ratio, PnL, and other
  key metrics MUST match the previous baseline exactly (within defined
  floating-point tolerance). Any deviation MUST block the merge.

## Governance

- This Constitution is the supreme governing document of the Tino project.
  It supersedes all other practices, conventions, and ad-hoc decisions.
- All pull requests and code reviews MUST verify compliance with the
  principles and standards defined herein. Non-compliance MUST be flagged
  and resolved before merge.
- **Amendment procedure**: Any proposed change to this Constitution MUST
  be submitted as a dedicated PR with a clear rationale. It MUST be
  reviewed and approved by at least the project owner before merge.
  Every amendment MUST update the version, record the amendment date,
  and include a Sync Impact Report documenting affected templates and
  downstream artifacts.
- **Versioning policy**: The Constitution follows semantic versioning
  (MAJOR.MINOR.PATCH). MAJOR for principle removals or redefinitions;
  MINOR for new principles or materially expanded guidance; PATCH for
  clarifications and wording fixes.
- **Compliance review**: At minimum, compliance with this Constitution
  MUST be verified at the start of every new feature planning cycle
  (during the Constitution Check gate in plan.md).
- For day-to-day development guidance, refer to the project's AGENTS.md
  or equivalent runtime development guide, which MUST remain consistent
  with this Constitution.

**Version**: 1.0.1 | **Ratified**: 2026-02-26 | **Last Amended**: 2026-02-26
